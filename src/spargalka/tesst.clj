;(println "Hello World!")
;(println (+ 1 2 4 7 3))
;(println (= 1 1 1 1))
;(println (> 2 1))
;(println (not= 1 2))
;
; (println (let [x 3
;      y 90]
;  (* 20 (+ 98 2(+ y x)))))
;
;(defn f [x y z]
;  (println(+ x y z)))
;
;(f 1 2 3)
;
;
;;(if <cond> <then> <else>)
;(if (< 1 1)
;  (println "true")
;  (println "false"))
;
;(and true true true true)
;(or false true)
;(and nil 1)
;;Возвращает первый false вариант
;(or nil 1)
;;Возвращает первый true вариант
;
;
;(defn factor [x acc]
;  (if (<= x 1)
;    acc
;    (recur (- x 1) (* acc x))))
;
;(println(factor 9 1))
;--------------------------------------------------------
;---------------------------------List--------------------------
'(1 2 3)
(list 1 2 3)
(conj '() 1)                                                ;=> '(1) Добавляет числа в начало листа
(conj '(1 2 3) 4)                                           ;=> '(4 1 2 3) Добавляет числа в начало листа
(first '(1 2 3))                                            ;Выводит первый элемент
(nth '(1 2 3) 0)                                            ;Показывает элемент по индексу с нуля
(count '(1 2 3))                                            ;Считает количество элементов
(reverse '(1 2 3))                                          ;Разворачивает
(next '(1 2 3))                                             ;Последний элемент
;-------------------------------Vector---------------------
[1 2 3]
(conj [1 2 3] 4 5)                                          ;Добавляет числа в вектор в конец


;(map <f> <coll>)                                           ;Функция map позволяет применить другую функцию к коллекции

(map inc [1 2 3 4])                                         ;=> (2 3 4 5) Инкремент прибавляет к каждому числу списка 1
(odd? 1)                                                    ;проверка нечетное ли это число. Ответ - true
(filter odd? [1 2 3 4 5 6 7 8 9])                           ;=> (1 3 5 7 9) Фильтр выводит только то, что задано в условии после него
(defn square [x] (* x x ))
(map square [1 2 3 4])

(let [f (fn [x] (* x x))]
  (f 9))                                                    ;Пример аноонимной функции, которая есть только локально здесь и сейчас
((fn [x] (* x x))9)                                         ;Пример аноонимной функции, которая есть только локально здесь и сейчас

;#(* % %) =============== (fn [x] (* x x))                  ;Анонимная функция сокращенно
;#(+ %1 %2) ================ (fn [x y] (+ x y))             ;Анонимная функция сокращенно


(range 100)                                                 ;0..99
(range 51 100)                                               ;1..99
(range 1 100 2)                                             ;1 3 5..99
(mod 100 7)                                                 ;Остаток от деления, в данном случае будет 2
;(take N <coll>)                                            ;=> first of coll
(take 10 (range))                                           ;Берет первые 10 элементов из коллекции

;(-> x (f _ a b) (g _ a b c))                               ;Засовывает каждую последующую функцию в начало
;(--> x (f a b _) (g a b c _))                              ;Засовывает каждую последующую функцию в конец
"(--> <x>
     (f1 a b <x>)
     (f2 (f1 a b <x>))
     (f3 (f2 (f1 a b <x>))))"

(take 10 (next (filter #(= 0 (mod % 7)) (range))))


(defn rev [list]
  (reduce conj '() list))
;(println (rev [1 2 3]))

(defn backwards [coll]
  (let [lenght (count coll)]
    (map #(nth coll (- lenght % 1)) (range 0 lenght))))
;(println(backwards [1 2 3]))


;(reduce <f acc el> <init> <coll>)                          ;функция что делать, потом начальное значение и коллекция

;(reduce (fn [acc el] (println acc el)) 0 [1 2 3])          ;0 1 nil 2 nil 3 nil
(reduce (fn [acc el] el) 0 [1 2 3])                         ;вычислит последний элемент 3
(reduce (fn [acc el] acc) 0 [1 2 3])                        ;вычислит первый элемент 1
(reduce (fn [acc el] (+ acc el)) 0 [1 2 3])                 ;вычислит сумму всех элементов


(defn Max [coll]
  (reduce #(if (> %1 %2) %1 %2) coll))                      ;выводит максимальное число из списка
;(println (Max [1 2 4 6 3 8 9 544 33]))                     ;544



;; Maps

{:a 1
 :b 2}                                                      ;ключи и значения

(assoc {} :a 1)                                             ;{:a 1}
(dissoc {:a 1 :b 2} :a)                                     ;останется {:b 2}, а первый ключ а и его значение исчезнет
(get {:a 1 :b 2 :c 3} :b)                                   ;выводит значение ключа b - 2
(keys {:a 1 :b 2})                                          ;Выведет все ключи - (:a :b)
(vals {:a 1 :b 2})                                          ;выведет все значения (1 2)
(get-in {:a {:b {:c 1}}} [:a :b :c])                        ;Выведет 1
(update {:a 1 :b 2 :c 3} :b inc)                            ;обновит ключ б на условие, в данном случае +1
(contains? {:a nil} :a)                                     ;Содержит ли этот элемент?


"-------------------------------------Вычесление времени-----------------------------------------"
;(println (time (some_func)))



















